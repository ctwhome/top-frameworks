name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    # Skip if commit is from the bot (prevents infinite loop)
    if: "!contains(github.event.head_commit.message, 'chore: bump version')"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest tag
        id: get_latest_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Determine version bump
        id: version_bump
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"

          # Remove 'v' prefix if present
          CURRENT_VERSION="${LATEST_TAG#v}"

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          # Get commits since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --oneline)
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline)
          fi

          echo "Commits since last tag:"
          echo "$COMMITS"

          # Determine bump type based on commit messages
          BUMP_TYPE="patch"

          # Check for breaking changes (major bump)
          if echo "$COMMITS" | grep -qiE "(BREAKING CHANGE|!:)"; then
            BUMP_TYPE="major"
          # Check for features (minor bump)
          elif echo "$COMMITS" | grep -qiE "^[a-f0-9]+ feat(\(|:)"; then
            BUMP_TYPE="minor"
          fi

          echo "Bump type: $BUMP_TYPE"

          # Calculate new version
          case $BUMP_TYPE in
            major)
              NEW_MAJOR=$((MAJOR + 1))
              NEW_VERSION="${NEW_MAJOR}.0.0"
              ;;
            minor)
              NEW_MINOR=$((MINOR + 1))
              NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
              ;;
            patch)
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
              ;;
          esac

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Check for changes
        id: check_changes
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"

          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMIT_COUNT=$(git rev-list --count HEAD)
          else
            COMMIT_COUNT=$(git rev-list --count ${LATEST_TAG}..HEAD)
          fi

          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "Commits since last tag: $COMMIT_COUNT"

          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        id: changelog
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"

          # Get commits since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%h %s" --reverse)
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%h %s" --reverse)
          fi

          # Initialize changelog sections
          BREAKING=""
          FEATURES=""
          FIXES=""
          DOCS=""
          MAINTENANCE=""
          OTHER=""

          # Parse commits and categorize
          while IFS= read -r line; do
            if [ -z "$line" ]; then continue; fi

            HASH=$(echo "$line" | cut -d' ' -f1)
            MSG=$(echo "$line" | cut -d' ' -f2-)

            # Categorize by conventional commit type
            if echo "$MSG" | grep -qiE "(BREAKING CHANGE|!:)"; then
              BREAKING="${BREAKING}- ${MSG} (${HASH})\n"
            elif echo "$MSG" | grep -qiE "^feat(\(|:)"; then
              FEATURES="${FEATURES}- ${MSG} (${HASH})\n"
            elif echo "$MSG" | grep -qiE "^fix(\(|:)"; then
              FIXES="${FIXES}- ${MSG} (${HASH})\n"
            elif echo "$MSG" | grep -qiE "^docs(\(|:)"; then
              DOCS="${DOCS}- ${MSG} (${HASH})\n"
            elif echo "$MSG" | grep -qiE "^(chore|ci|build|refactor|style|test|perf)(\(|:)"; then
              MAINTENANCE="${MAINTENANCE}- ${MSG} (${HASH})\n"
            else
              OTHER="${OTHER}- ${MSG} (${HASH})\n"
            fi
          done <<< "$COMMITS"

          # Build changelog
          CHANGELOG="## What's Changed in v${NEW_VERSION}\n\n"

          if [ -n "$BREAKING" ]; then
            CHANGELOG="${CHANGELOG}### Breaking Changes\n${BREAKING}\n"
          fi

          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### Features\n${FEATURES}\n"
          fi

          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### Bug Fixes\n${FIXES}\n"
          fi

          if [ -n "$DOCS" ]; then
            CHANGELOG="${CHANGELOG}### Documentation\n${DOCS}\n"
          fi

          if [ -n "$MAINTENANCE" ]; then
            CHANGELOG="${CHANGELOG}### Maintenance\n${MAINTENANCE}\n"
          fi

          if [ -n "$OTHER" ]; then
            CHANGELOG="${CHANGELOG}### Other Changes\n${OTHER}\n"
          fi

          # Output for GitHub release body
          {
            echo "changelog<<EOF"
            echo -e "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Update package.json version
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"

          if [ -f "package.json" ]; then
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              pkg.version = '${NEW_VERSION}';
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, '\t') + '\n');
            "
            echo "Updated package.json to version ${NEW_VERSION}"
          fi

      - name: Configure Git
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit version updates
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"

          git add package.json 2>/dev/null || true

          if git diff --staged --quiet; then
            echo "No version file changes to commit"
          else
            git commit -m "chore: bump version to ${NEW_VERSION}"
          fi

      - name: Create and push tag
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"

          # Push commits first
          git push origin main

          # Create and push tag
          git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
          git push origin "v${NEW_VERSION}"

      - name: Create GitHub Release
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version_bump.outputs.new_version }}
          name: v${{ steps.version_bump.outputs.new_version }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: v${{ steps.version_bump.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump Type**: ${{ steps.version_bump.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commits**: ${{ steps.check_changes.outputs.commit_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.changelog.outputs.changelog }}" >> $GITHUB_STEP_SUMMARY

      - name: No changes
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo "No changes since last release. Skipping."
          echo "## No Release Needed" >> $GITHUB_STEP_SUMMARY
          echo "No commits since last tag (${{ steps.get_latest_tag.outputs.latest_tag }})" >> $GITHUB_STEP_SUMMARY
